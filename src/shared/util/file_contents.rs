use crate::shared::config::Config;
use crate::shared::util::executable::make_executable;
use crate::shared::{RS_SCRIPT_VERSION, VERBOSE};
use crate::time;
use color_print::{cformat, cprint, cprintln};
use human_bytes::human_bytes;
use num_format::{Locale, ToFormattedString};
use std::borrow::Cow;
use std::fs;
use std::path::Path;

type LengthType = u64;
const LENGTH_TYPE_SIZE: usize = size_of::<LengthType>();

// ! This is the only thing about the layout that cannot be changed
type LayoutVersionType = u32;
const LAYOUT_VERSION_SIZE: usize = size_of::<LayoutVersionType>();

// ! List of layout versions and newest rs-script version that supports them
// ! Last entry is the current layout version
const LAYOUT_VERSIONS: [(LayoutVersionType, &str); 2] = [(1, "0.2.25"), (2, "0.3.4")];

#[allow(dead_code)]
const fn version_check() -> bool {
    slice_eq!(
        LAYOUT_VERSIONS.last().unwrap().1.as_bytes(),
        RS_SCRIPT_VERSION.as_bytes()
    )
}
const_assert!(version_check());

const CURRENT_LAYOUT_VERSION: LayoutVersionType = LAYOUT_VERSIONS.last().unwrap().0;

fn check_layout_version(layout_version: LayoutVersionType) -> Result<(), String> {
    if layout_version != CURRENT_LAYOUT_VERSION {
        let last_supported = LAYOUT_VERSIONS
            .iter()
            .find(|(v, _)| *v == layout_version)
            .map(|(_, v)| *v);

        return if let Some(last_supported) = last_supported {
            Err(cformat!(
                "<bold>E76 Unsupported layout version: {layout_version} (current is {CURRENT_LAYOUT_VERSION}).</>\n\
                <cyan>The last rs-script release that supported this version is {last_supported} (current is {RS_SCRIPT_VERSION}):</>\n\
                <green>-> Install that version, extract the project, and then pack it in the latest version.</>"
            ))
        } else {
            Err(cformat!(
                "<bold>E77 Unrecognised layout version: {layout_version} (current is {CURRENT_LAYOUT_VERSION}).</>\n\
                <cyan>The rss file is may be:</>\n\
                - Generated by a newer version of rs-script this version is unaware of (current is {RS_SCRIPT_VERSION})\n\
                - Corrupted\n\
                - Generated by a version before 0.2.17 (before layout versioning, unlikely)\n\
                <green>The latest version of rs-script can always detect all previous layouts</>\n\
                <yellow>If the file was created by a version before 0.2.17, extract the project in that version and then pack it in the latest version.</>",
            ))
        };
    }
    Ok(())
}

const SHEBANG_TEXT: &[u8] = b"#!/usr/bin/env rss-run\n";

pub struct FileContents {
    layout_version: LayoutVersionType,
    contents: Vec<u8>,
    triple_length: usize,
    zip_length: usize,
}

impl FileContents {
    pub fn new(zipped_contents: Vec<u8>, binary_contents: Vec<u8>, triple: &str) -> Self {
        let mut final_contents = Vec::new();
        final_contents.extend_from_slice(SHEBANG_TEXT); // shebang
        final_contents.extend_from_slice(&(zipped_contents.len() as LengthType).to_le_bytes()); // zipped len
        final_contents.extend_from_slice(&zipped_contents); // zipped
        final_contents.extend_from_slice(&(triple.len() as LengthType).to_le_bytes()); // triple len
        final_contents.extend(triple.as_bytes()); // triple
        final_contents.extend_from_slice(&binary_contents); // binary
        final_contents.extend_from_slice(&CURRENT_LAYOUT_VERSION.to_le_bytes()); // Layout version
        FileContents {
            layout_version: CURRENT_LAYOUT_VERSION,
            contents: final_contents,
            triple_length: triple.len(),
            zip_length: zipped_contents.len(),
        }
    }

    pub fn remove_binary(&mut self) {
        self.contents.truncate(
            SHEBANG_TEXT.len()
                + LENGTH_TYPE_SIZE
                + self.zip_length
                + LENGTH_TYPE_SIZE
                + self.triple_length,
        );
        self.contents
            .extend_from_slice(&CURRENT_LAYOUT_VERSION.to_le_bytes());
    }

    pub fn replace_binary(&mut self, triple: &str, binary: &[u8]) {
        self.contents
            .truncate(SHEBANG_TEXT.len() + LENGTH_TYPE_SIZE + self.zip_length);
        self.triple_length = triple.len();
        self.contents
            .extend_from_slice((triple.len() as LengthType).to_le_bytes().as_ref()); // triple len
        self.contents.extend(triple.as_bytes()); // triple
        self.contents.extend_from_slice(binary); // binary
        self.contents
            .extend_from_slice(&CURRENT_LAYOUT_VERSION.to_le_bytes());
    }

    pub fn print_stats(&self, file_name: &str) {
        let verbose = *VERBOSE.get().unwrap();
        cprintln!(
            "{} [Layout: <green, bold>v{}</> | Target: <green, bold>{}</>]:",
            file_name,
            self.layout_version,
            self.target_triple()
        );

        let shebang_size_str = human_bytes(SHEBANG_TEXT.len() as f64);
        let zip_size = LENGTH_TYPE_SIZE + self.zip_length;
        let zip_size_str = human_bytes(zip_size as f64);
        let triple_size = LENGTH_TYPE_SIZE + self.triple_length;
        let triple_size_str = human_bytes(triple_size as f64);
        let binary_size = self.contents.len()
            - SHEBANG_TEXT.len()
            - LENGTH_TYPE_SIZE
            - self.zip_length
            - LENGTH_TYPE_SIZE
            - self.triple_length
            - LAYOUT_VERSION_SIZE;
        let binary_size_str = human_bytes(binary_size as f64);
        let layout_size_str = human_bytes(LAYOUT_VERSION_SIZE as f64);
        let total_size = self.contents.len();
        let total_size_str = human_bytes(total_size as f64);
        let max_len = *[
            shebang_size_str.len(),
            zip_size_str.len(),
            triple_size_str.len(),
            binary_size_str.len(),
            total_size_str.len(),
            layout_size_str.len(),
        ]
        .iter()
        .max()
        .unwrap();

        let verbose_bytes = |bytes: usize, cur_len: usize, show_percent: bool| -> String {
            if verbose {
                if show_percent {
                    format!(
                        "{} [{} bytes | {:.2}%]",
                        " ".repeat(max_len - cur_len),
                        bytes.to_formatted_string(&Locale::en),
                        (bytes as f64 / total_size as f64) * 100.0
                    )
                } else {
                    format!(
                        "{} [{} bytes]",
                        " ".repeat(max_len - cur_len),
                        bytes.to_formatted_string(&Locale::en)
                    )
                }
            } else {
                "".to_owned()
            }
        };

        if verbose {
            cprintln!(
                "  - Shebang size:  <cyan>{}</>{}",
                shebang_size_str,
                verbose_bytes(SHEBANG_TEXT.len(), shebang_size_str.len(), true)
            );
        }
        cprintln!(
            "  - Project zip size:       <cyan>{}</>{}",
            zip_size_str,
            verbose_bytes(zip_size, zip_size_str.len(), true)
        );

        if verbose {
            cprintln!(
                "  - Target indicator size:  <cyan>{}</>{}",
                triple_size_str,
                verbose_bytes(triple_size, triple_size_str.len(), true)
            );
        }

        cprint!(
            "  - Binary size:            <cyan>{}</>{}",
            binary_size_str,
            verbose_bytes(binary_size, binary_size_str.len(), true)
        );

        if binary_size == 0 {
            cprintln!("<red> (no binary)</>");
        } else {
            println!();
        }

        if verbose {
            cprintln!(
                "  - Layout indicator size:  <cyan>{}</>{}",
                layout_size_str,
                verbose_bytes(LAYOUT_VERSION_SIZE, layout_size_str.len(), true)
            );
        }

        cprintln!(
            "  Total size:               <cyan>{}</>{}",
            total_size_str,
            verbose_bytes(total_size, total_size_str.len(), false)
        );
    }

    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<Option<FileContents>, String> {
        if !path.as_ref().exists() {
            return Ok(None);
        }
        let original_contents = time!(
            "Reading rss file",
            false,
            fs::read(&path).map_err(|e| format!("E07 Failed to read file: {}", e))?
        );
        let contents = &original_contents;

        if contents.len() < LAYOUT_VERSION_SIZE {
            return Err(format!("Corrupted file: {:?} [E75]", path.as_ref()));
        }

        if contents[..LAYOUT_VERSION_SIZE] != SHEBANG_TEXT[..LAYOUT_VERSION_SIZE] {
            // Layouts before v2 have layout version at start instead of shebang
            let layout_version = LayoutVersionType::from_le_bytes(
                contents[..LAYOUT_VERSION_SIZE].try_into().unwrap(),
            );
            check_layout_version(layout_version)?; // Should fail, if not must be corrupted
            return Err(format!("Corrupted file: {:?} [E84]", path.as_ref()));
        }

        // ? Layout version (end)
        let layout_version = LayoutVersionType::from_le_bytes(
            contents[contents.len() - LAYOUT_VERSION_SIZE..]
                .try_into()
                .unwrap(),
        );
        check_layout_version(layout_version)?;
        let contents = &contents[..contents.len() - LAYOUT_VERSION_SIZE];

        let mut cursor = 0;

        // ? Shebang
        cursor += SHEBANG_TEXT.len();

        // ? Zip
        if contents.len() < cursor + LENGTH_TYPE_SIZE {
            return Err(format!("Corrupted file: {:?} [E1]", path.as_ref()));
        }
        let zipped_len = LengthType::from_le_bytes(
            contents[cursor..cursor + LENGTH_TYPE_SIZE]
                .try_into()
                .unwrap(),
        ) as usize;
        cursor += LENGTH_TYPE_SIZE;
        cursor += zipped_len;

        // ? Target triple
        if contents.len() < cursor + LENGTH_TYPE_SIZE {
            return Err(format!("Corrupted file: {:?} [E2]", path.as_ref()));
        }
        let triple_len = LengthType::from_le_bytes(
            contents[cursor..cursor + LENGTH_TYPE_SIZE]
                .try_into()
                .unwrap(),
        ) as usize;
        cursor += LENGTH_TYPE_SIZE;
        if contents.len() < cursor + triple_len {
            return Err(format!("Corrupted file: {:?} [E46]", path.as_ref()));
        }

        Ok(Some(FileContents {
            layout_version,
            contents: original_contents,
            triple_length: triple_len,
            zip_length: zipped_len,
        }))
    }

    pub fn zipped_contents(&self) -> &[u8] {
        &self.contents[SHEBANG_TEXT.len() + LENGTH_TYPE_SIZE
            ..SHEBANG_TEXT.len() + LENGTH_TYPE_SIZE + self.zip_length]
    }

    pub fn target_triple(&self) -> Cow<'_, str> {
        String::from_utf8_lossy(
            &self.contents[SHEBANG_TEXT.len()
                + LENGTH_TYPE_SIZE
                + self.zip_length
                + LENGTH_TYPE_SIZE
                ..SHEBANG_TEXT.len()
                    + LENGTH_TYPE_SIZE
                    + self.zip_length
                    + LENGTH_TYPE_SIZE
                    + self.triple_length],
        )
    }

    pub fn bin_contents(&self) -> &[u8] {
        &self.contents[SHEBANG_TEXT.len()
            + LENGTH_TYPE_SIZE
            + self.zip_length
            + LENGTH_TYPE_SIZE
            + self.triple_length..self.contents.len() - LAYOUT_VERSION_SIZE]
    }

    pub fn save<P: AsRef<Path>>(&self, path: P, config: &Config) -> Result<(), String> {
        fs::write(path.as_ref(), &self.contents)
            .map_err(|e| format!("E08 Failed to write file: {}", e))?;

        #[cfg(unix)]
        if config.make_rss_executable_linux() {
            make_executable(path)?;
        }

        Ok(())
    }
}
