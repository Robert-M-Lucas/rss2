use crate::time;
use crate::{RS_SCRIPT_VERSION, VERBOSE};
use color_print::{cformat, cprint, cprintln};
use human_bytes::human_bytes;
use num_format::{Locale, ToFormattedString};
use std::borrow::Cow;
use std::fs;
use std::path::Path;

type LengthType = u64;
const LENGTH_TYPE_SIZE: usize = size_of::<LengthType>();

// ! This is the only thing about the layout that cannot be changed
type LayoutVersionType = u32;
const LAYOUT_VERSION_SIZE: usize = size_of::<LayoutVersionType>();

// ! List of layout versions and newest rs-script version that supports them
// ! Last entry is the current layout version
const LAYOUT_VERSIONS: [(LayoutVersionType, &str); 1] = [(1, "0.2.26")];
#[allow(dead_code)]
const fn version_check() -> bool {
    slice_eq!(
        LAYOUT_VERSIONS.last().unwrap().1.as_bytes(),
        RS_SCRIPT_VERSION.as_bytes()
    )
}
const_assert!(version_check());

const CURRENT_LAYOUT_VERSION: LayoutVersionType = LAYOUT_VERSIONS.last().unwrap().0;

fn check_layout_version(layout_version: LayoutVersionType) -> Result<(), String> {
    if layout_version != CURRENT_LAYOUT_VERSION {
        let last_supported = LAYOUT_VERSIONS
            .iter()
            .find(|(v, _)| *v == layout_version)
            .map(|(_, v)| *v);

        return if let Some(last_supported) = last_supported {
            Err(format!(
                "E76 Unsupported layout version: {layout_version} (current is {CURRENT_LAYOUT_VERSION}).\n\
                The last rs-script release that supported this version is {last_supported} (current is {RS_SCRIPT_VERSION}):\n\
                -> Install that version, extract the project, and then pack it in the latest version."
            ))
        } else {
            Err(cformat!(
                "E77 Unrecognised layout version: {layout_version} (current is {CURRENT_LAYOUT_VERSION}).\n\
                <cyan>The rss file is may be:</>\n\
                - Generated by a newer version of rs-script this version is unaware of (current is {RS_SCRIPT_VERSION})\n\
                - Generated by a version before 0.2.17 (before layout versioning)\n\
                - Corrupted\n\
                <green>The latest version of rs-script can always detect all previous layouts</>\n\
                <yellow>If the file was created by a version before 0.2.17, extract the project in that version and then pack it in the latest version.</>",
            ))
        };
    }
    Ok(())
}

pub struct FileContents {
    layout_version: LayoutVersionType,
    contents: Vec<u8>,
    triple_length: usize,
    zip_length: usize,
}

impl FileContents {
    pub fn new(zipped_contents: Vec<u8>, binary_contents: Vec<u8>, triple: &str) -> Self {
        let mut final_contents =
            Vec::with_capacity(LENGTH_TYPE_SIZE + zipped_contents.len() + binary_contents.len());
        final_contents.extend_from_slice(&CURRENT_LAYOUT_VERSION.to_le_bytes());
        final_contents.extend_from_slice(&(zipped_contents.len() as LengthType).to_le_bytes()); // zipped len
        final_contents.extend_from_slice(&zipped_contents); // zipped
        final_contents.extend_from_slice(&(triple.len() as LengthType).to_le_bytes()); // triple len
        final_contents.extend(triple.as_bytes()); // triple
        final_contents.extend_from_slice(&binary_contents); // binary
        FileContents {
            layout_version: CURRENT_LAYOUT_VERSION,
            contents: final_contents,
            triple_length: triple.len(),
            zip_length: zipped_contents.len(),
        }
    }

    pub fn remove_binary(&mut self) {
        self.contents.truncate(
            LAYOUT_VERSION_SIZE
                + LENGTH_TYPE_SIZE
                + self.zip_length
                + LENGTH_TYPE_SIZE
                + self.triple_length,
        );
    }

    pub fn replace_binary(&mut self, triple: &str, binary: &[u8]) {
        self.contents
            .truncate(LAYOUT_VERSION_SIZE + LENGTH_TYPE_SIZE + self.zip_length);
        self.triple_length = triple.len();
        self.contents
            .extend_from_slice((triple.len() as LengthType).to_le_bytes().as_ref()); // triple len
        self.contents.extend(triple.as_bytes()); // triple
        self.contents.extend_from_slice(binary); // binary
    }

    pub fn print_stats(&self, file_name: &str) {
        let verbose = *VERBOSE.get().unwrap();
        cprintln!(
            "{} [Layout: <green, bold>v{}</> | Target: <green, bold>{}</>]:",
            file_name,
            self.layout_version,
            self.target_triple()
        );

        let layout_size_str = human_bytes(LAYOUT_VERSION_SIZE as f64);
        let zip_size = LENGTH_TYPE_SIZE + self.zip_length;
        let zip_size_str = human_bytes(zip_size as f64);
        let triple_size = LENGTH_TYPE_SIZE + self.triple_length;
        let triple_size_str = human_bytes(triple_size as f64);
        let binary_size = self.contents.len()
            - LAYOUT_VERSION_SIZE
            - LENGTH_TYPE_SIZE
            - self.zip_length
            - LENGTH_TYPE_SIZE
            - self.triple_length;
        let binary_size_str = human_bytes(binary_size as f64);
        let total_size = self.contents.len();
        let total_size_str = human_bytes(total_size as f64);
        let max_len = *[
            zip_size_str.len(),
            triple_size_str.len(),
            binary_size_str.len(),
            total_size_str.len(),
        ]
        .iter()
        .max()
        .unwrap();

        let verbose_bytes = |bytes: usize, cur_len: usize, show_percent: bool| -> String {
            if verbose {
                if show_percent {
                    format!(
                        "{} [{} bytes | {:.2}%]",
                        " ".repeat(max_len - cur_len),
                        bytes.to_formatted_string(&Locale::en),
                        (bytes as f64 / total_size as f64) * 100.0
                    )
                } else {
                    format!(
                        "{} [{} bytes]",
                        " ".repeat(max_len - cur_len),
                        bytes.to_formatted_string(&Locale::en)
                    )
                }
            } else {
                "".to_owned()
            }
        };

        cprintln!(
            "  - Layout indicator size:  <cyan>{}</>{}",
            layout_size_str,
            verbose_bytes(LAYOUT_VERSION_SIZE, layout_size_str.len(), true)
        );
        cprintln!(
            "  - Project zip size:       <cyan>{}</>{}",
            zip_size_str,
            verbose_bytes(zip_size, zip_size_str.len(), true)
        );
        cprintln!(
            "  - Target indicator size:  <cyan>{}</>{}",
            triple_size_str,
            verbose_bytes(triple_size, triple_size_str.len(), true)
        );
        cprint!(
            "  - Binary size:            <cyan>{}</>{}",
            binary_size_str,
            verbose_bytes(binary_size, binary_size_str.len(), true)
        );

        if binary_size == 0 {
            cprintln!("<red> (no binary)</>");
        } else {
            println!();
        }

        cprintln!(
            "  Total size:               <cyan>{}</>{}",
            total_size_str,
            verbose_bytes(total_size, total_size_str.len(), false)
        );
    }

    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<Option<FileContents>, String> {
        if !path.as_ref().exists() {
            return Ok(None);
        }
        let contents = time!(
            "Reading rss file",
            false,
            fs::read(&path).map_err(|e| format!("E07 Failed to read file: {}", e))?
        );

        let mut cursor = 0;
        if contents.len() < cursor + LAYOUT_VERSION_SIZE {
            return Err(format!("Corrupted file: {:?} [E75]", path.as_ref()));
        }
        let layout_version = LayoutVersionType::from_le_bytes(
            contents[cursor..cursor + LAYOUT_VERSION_SIZE]
                .try_into()
                .unwrap(),
        );
        check_layout_version(layout_version)?;
        cursor += LAYOUT_VERSION_SIZE;

        if contents.len() < cursor + LENGTH_TYPE_SIZE {
            return Err(format!("Corrupted file: {:?} [E1]", path.as_ref()));
        }
        let zipped_len = LengthType::from_le_bytes(
            contents[cursor..cursor + LENGTH_TYPE_SIZE]
                .try_into()
                .unwrap(),
        ) as usize;
        cursor += LENGTH_TYPE_SIZE;
        cursor += zipped_len;

        // Check for zipped length + target triple length indicator
        if contents.len() < cursor + LENGTH_TYPE_SIZE {
            return Err(format!("Corrupted file: {:?} [E2]", path.as_ref()));
        }

        let triple_len = LengthType::from_le_bytes(
            contents[cursor..cursor + LENGTH_TYPE_SIZE]
                .try_into()
                .unwrap(),
        ) as usize;
        cursor += LENGTH_TYPE_SIZE;

        if contents.len() < cursor + triple_len {
            return Err(format!("Corrupted file: {:?} [E46]", path.as_ref()));
        }

        Ok(Some(FileContents {
            layout_version,
            contents,
            triple_length: triple_len,
            zip_length: zipped_len,
        }))
    }

    pub fn zipped_contents(&self) -> &[u8] {
        &self.contents[LAYOUT_VERSION_SIZE + LENGTH_TYPE_SIZE
            ..LAYOUT_VERSION_SIZE + LENGTH_TYPE_SIZE + self.zip_length]
    }

    pub fn target_triple(&self) -> Cow<str> {
        String::from_utf8_lossy(
            &self.contents[LAYOUT_VERSION_SIZE
                + LENGTH_TYPE_SIZE
                + self.zip_length
                + LENGTH_TYPE_SIZE
                ..LAYOUT_VERSION_SIZE
                    + LENGTH_TYPE_SIZE
                    + self.zip_length
                    + LENGTH_TYPE_SIZE
                    + self.triple_length],
        )
    }

    pub fn bin_contents(&self) -> &[u8] {
        &self.contents[LAYOUT_VERSION_SIZE
            + LENGTH_TYPE_SIZE
            + self.zip_length
            + LENGTH_TYPE_SIZE
            + self.triple_length..]
    }

    pub fn save<P: AsRef<Path>>(&self, path: P) -> Result<(), String> {
        fs::write(path, &self.contents).map_err(|e| format!("E08 Failed to write file: {}", e))
    }
}
