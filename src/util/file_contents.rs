use crate::time;
use color_print::{cprint, cprintln};
use human_bytes::human_bytes;
use std::borrow::Cow;
use std::fs;
use std::path::Path;

type LengthType = u64;
const LENGTH_TYPE_SIZE: usize = size_of::<LengthType>();

// ! This is the only thing about the layout that cannot be changed
type LayoutVersionType = u32;
const LAYOUT_VERSION_SIZE: usize = size_of::<LayoutVersionType>();

// ! List of layout versions and newest rs-script version that supports them
// ! Last entry is the current layout version
const LAYOUT_VERSIONS: [(LayoutVersionType, &str); 1] = [(1, "0.2.17")];

const CURRENT_LAYOUT_VERSION: LayoutVersionType = LAYOUT_VERSIONS.last().unwrap().0;

fn check_layout_version(layout_version: LayoutVersionType) -> Result<(), String> {
    if layout_version != CURRENT_LAYOUT_VERSION {
        let last_supported = LAYOUT_VERSIONS
            .iter()
            .find(|(v, _)| *v == layout_version)
            .map(|(_, v)| *v);

        return if let Some(last_supported) = last_supported {
            Err(format!(
                "E76 Unsupported layout version: {layout_version} (current is {CURRENT_LAYOUT_VERSION}).\n\
                The last rs-script release that supported this version is {last_supported} (current is {}):\n\
                -> Install that version, extract the project, and then repack in the latest version.",
                env!("CARGO_PKG_VERSION")
            ))
        } else {
            Err(format!(
                "E77 Unrecognised layout version: {layout_version} (current is {CURRENT_LAYOUT_VERSION}).\n\
                The rss file is may be:\n\
                - Generated by a newer version of rs-script (current is {})\n\
                - Generated by a version before 0.2.17 (before layout versioning)\n\
                - Corrupted\n\
                If the file was created by a version before 0.2.17, extract the project in that version and repack it in the latest version.",
                env!("CARGO_PKG_VERSION")
            ))
        }
    }
    Ok(())
}

pub struct FileContents {
    layout_version: LayoutVersionType,
    contents: Vec<u8>,
    triple_length: usize,
    zip_length: usize,
}

impl FileContents {
    pub fn new(zipped_contents: Vec<u8>, binary_contents: Vec<u8>, triple: &str) -> Self {
        let mut final_contents =
            Vec::with_capacity(LENGTH_TYPE_SIZE + zipped_contents.len() + binary_contents.len());
        final_contents.extend_from_slice(&CURRENT_LAYOUT_VERSION.to_le_bytes());
        final_contents.extend_from_slice(&(zipped_contents.len() as LengthType).to_le_bytes()); // zipped len
        final_contents.extend_from_slice(&zipped_contents); // zipped
        final_contents.extend_from_slice(&(triple.len() as LengthType).to_le_bytes()); // triple len
        final_contents.extend(triple.as_bytes()); // triple
        final_contents.extend_from_slice(&binary_contents); // binary
        FileContents {
            layout_version: CURRENT_LAYOUT_VERSION,
            contents: final_contents,
            triple_length: triple.len(),
            zip_length: zipped_contents.len(),
        }
    }

    pub fn remove_binary(&mut self) {
        self.contents.truncate(
            LAYOUT_VERSION_SIZE
                + LENGTH_TYPE_SIZE
                + self.zip_length
                + LENGTH_TYPE_SIZE
                + self.triple_length,
        );
    }

    pub fn replace_binary(&mut self, triple: &str, binary: &[u8]) {
        self.contents
            .truncate(LAYOUT_VERSION_SIZE + LENGTH_TYPE_SIZE + self.zip_length);
        self.triple_length = triple.len();
        self.contents
            .extend_from_slice((triple.len() as LengthType).to_le_bytes().as_ref()); // triple len
        self.contents.extend(triple.as_bytes()); // triple
        self.contents.extend_from_slice(binary); // binary
    }

    pub fn print_stats(&self, file_name: &str) {
        cprintln!(
            "{} <green, bold>(Layout version {}])</>:",
            file_name,
            self.layout_version
        );
        cprintln!(
            "  - Layout version indicator size: <cyan>{}</>",
            human_bytes(LAYOUT_VERSION_SIZE as f64)
        );
        cprintln!(
            "  - Project zip size: <cyan>{}</>",
            human_bytes((LENGTH_TYPE_SIZE + self.zip_length) as f64)
        );
        cprintln!(
            "  - Target triple indicator size: <cyan>{}</>",
            human_bytes((LENGTH_TYPE_SIZE + self.triple_length) as f64)
        );
        cprint!(
            "  - Binary size: <cyan>{}</>",
            human_bytes(
                (self.contents.len()
                    - LAYOUT_VERSION_SIZE
                    - LENGTH_TYPE_SIZE
                    - self.zip_length
                    - LENGTH_TYPE_SIZE
                    - self.triple_length) as f64
            )
        );
        if self.contents.len()
            - LAYOUT_VERSION_SIZE
            - LENGTH_TYPE_SIZE
            - self.zip_length
            - LENGTH_TYPE_SIZE
            - self.triple_length
            == 0
        {
            cprintln!("<red> (no binary)</>");
        } else {
            println!();
        }
        cprintln!(
            "  Total size: <cyan>{}</>",
            human_bytes(self.contents.len() as f64)
        );
    }

    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<Option<FileContents>, String> {
        if !path.as_ref().exists() {
            return Ok(None);
        }
        let contents = time!(
            "Reading rss file",
            false,
            fs::read(&path).map_err(|e| format!("E07 Failed to read file: {}", e))?
        );

        let mut cursor = 0;
        if contents.len() < cursor + LAYOUT_VERSION_SIZE {
            return Err(format!("Corrupted file: {:?} [E75]", path.as_ref()));
        }
        let layout_version = LayoutVersionType::from_le_bytes(
            contents[cursor..cursor + LAYOUT_VERSION_SIZE]
                .try_into()
                .unwrap(),
        );
        check_layout_version(layout_version)?;
        cursor += LAYOUT_VERSION_SIZE;

        if contents.len() < cursor + LENGTH_TYPE_SIZE {
            return Err(format!("Corrupted file: {:?} [E1]", path.as_ref()));
        }
        let zipped_len = LengthType::from_le_bytes(
            contents[cursor..cursor + LENGTH_TYPE_SIZE]
                .try_into()
                .unwrap(),
        ) as usize;
        cursor += LENGTH_TYPE_SIZE;
        cursor += zipped_len;

        // Check for zipped length + target triple length indicator
        if contents.len() < cursor + LENGTH_TYPE_SIZE {
            return Err(format!("Corrupted file: {:?} [E2]", path.as_ref()));
        }

        let triple_len = LengthType::from_le_bytes(
            contents[cursor..cursor + LENGTH_TYPE_SIZE]
                .try_into()
                .unwrap(),
        ) as usize;
        cursor += LENGTH_TYPE_SIZE;

        if contents.len() < cursor + triple_len {
            return Err(format!("Corrupted file: {:?} [E46]", path.as_ref()));
        }

        Ok(Some(FileContents {
            layout_version,
            contents,
            triple_length: triple_len,
            zip_length: zipped_len,
        }))
    }

    pub fn zipped_contents(&self) -> &[u8] {
        &self.contents[LAYOUT_VERSION_SIZE + LENGTH_TYPE_SIZE
            ..LAYOUT_VERSION_SIZE + LENGTH_TYPE_SIZE + self.zip_length]
    }

    pub fn target_triple(&self) -> Cow<str> {
        String::from_utf8_lossy(
            &self.contents[LAYOUT_VERSION_SIZE
                + LENGTH_TYPE_SIZE
                + self.zip_length
                + LENGTH_TYPE_SIZE
                ..LAYOUT_VERSION_SIZE
                    + LENGTH_TYPE_SIZE
                    + self.zip_length
                    + LENGTH_TYPE_SIZE
                    + self.triple_length],
        )
    }

    pub fn bin_contents(&self) -> &[u8] {
        &self.contents[LAYOUT_VERSION_SIZE
            + LENGTH_TYPE_SIZE
            + self.zip_length
            + LENGTH_TYPE_SIZE
            + self.triple_length..]
    }

    pub fn save<P: AsRef<Path>>(&self, path: P) -> Result<(), String> {
        fs::write(path, &self.contents).map_err(|e| format!("E08 Failed to write file: {}", e))
    }
}
